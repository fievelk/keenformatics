---
layout: post
title: Model-Driven approach vs hardcore coding
date: '2014-02-18T12:13:00.001+01:00'
author: fievelk
tags:
- thoughts
- Model-Driven
modified_time: '2014-02-18T12:13:16.972+01:00'
thumbnail: http://2.bp.blogspot.com/-D9kHMnAsbbA/UwM7cgJNF9I/AAAAAAAAASM/W7u9VF544Ec/s72-c/mda_and_coding.jpg
blogger_id: tag:blogger.com,1999:blog-8196940592943844696.post-5551449740151255135
blogger_orig_url: http://keenformatics.blogspot.com/2014/02/model-driven-approach-vs-hardcore-coding.html
image:
  feature: http://2.bp.blogspot.com/-D9kHMnAsbbA/UwM7cgJNF9I/AAAAAAAAASM/W7u9VF544Ec/s1600/mda_and_coding.jpg
excerpt: "<strong>Model-driven architecture</strong> (MDA) essentially represents a different approach to programming and software development, intended to provide an abstract structure in the realization of those tasks that are usually accomplished by (more or less hardcore) manual coding. Ideally, a model driven approach is supposed to provide an easy-to-follow guideline which can improve code reusability while shortening development times. But <strong>can it really be thought as a real substitute for old-style coding?</strong> I don't think so, yet I think that MDA approach can anyway represent a precious ally for programmers."
---

<section><a href="http://2.bp.blogspot.com/-D9kHMnAsbbA/UwM7cgJNF9I/AAAAAAAAASM/W7u9VF544Ec/s1600/mda_and_coding.jpg" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="235" src="http://2.bp.blogspot.com/-D9kHMnAsbbA/UwM7cgJNF9I/AAAAAAAAASM/W7u9VF544Ec/s320/mda_and_coding.jpg" width="320" /></a><p><strong>Model-driven architecture</strong> (MDA) essentially represents a different approach to programming and software development, intended to provide an abstract structure in the realization of those tasks that are usually accomplished by (more or less hardcore) manual coding. Ideally, a model driven approach is supposed to provide an easy-to-follow guideline which can improve code reusability while shortening development times. But <strong>can it really be thought as a real substitute for old-style coding?</strong> I don't think so, yet I think that MDA approach can anyway represent a precious ally for programmers.</p></section>  <section><p>First of all, we have to face the fact that asking if a MDA approach can substitute "traditional" programming already represents a misunderstanding. MDA, often combined with Agile approach and diagrams modeling, <i>defines system functionality using a platform-independent model (PIM) using an appropriate domain-specific language (DSL)</i> (see <a href="http://en.wikipedia.org/wiki/Model-driven_architecture">Model-Driven Architecture</a>). So its natural placement <strong>structurally preceeds coding</strong>. For example, there are thousand (or millions?) of programmers that dauntlessly engage their coding sessions without drawing diagrams and schemas: those braves won't need an MDA approach, which will almost certainly result frustrating for their usual habits. Let's assume they've got their good reasons to choose this type of approach. Typical MDA users, instead, will look for something more complex that can guide them through a long path of <strong>decisions and revisions</strong>, usually made by different actors in an enterprise context. In general, each of these experts will manage his own models and diagrams, bringing his contribution to a global <a href="http://en.wikipedia.org/wiki/Unified_Process">Unified Process</a>. Executable code implementation will be just one of the many steps on this path, not even the last one. So, MDA and traditional coding are different practices, and they often mirror different needs. </p> <p>Moreover, differences between traditional coding and MDA approach can also be found when speaking about <strong>time scheduling</strong>. I won't assert that there's something like a "winner" between the two, since there's not. More precisely, each of the two approaches will guarantee a time saving when used in the appropriate situation. If you're a coder and you want to create a simple blog, or a small site for which you already prepared all needed libraries, using an MDA approach (or even a MDA framework) will probably become an useless and tedious waste of time, unless you want to take advantage of modeling to better understand your application structure. On the contrary, if you're part of a big company, you'll be absolutely facilitated using an MDA approach in an iterative Unified Process, and the whole process will speed up (given that every member of the team knows how to manage his own task). </p> <p>Moreover, probably the most controversial side of a hypotetical comparison between MDA approach and hardcore programming is that of <strong>code generation</strong>. Good automated tools can generate source code starting from the models that MDA actors created during Unified Process iteration. But what does this generated code look like? Does it follow shared standards? Do models model every single part of this code, or something is silently invented during generation (breaking coders trust in automated generation)? This is one of the most complicated tasks that a good MDA framework has to carry out. It has to be confortable enough to make its use worthwhile, but it should at the same time provide a way to mix "manual" coding with model generation, in order to allow programmers to customize their source code when they need to. </p> <p>Finally, MDA frameworks often rely on <strong>a myriad of different technologies</strong> and frameworks (e.g. Spring MVC, Apache Wicket, Spring WebFlow, Apache Tiles, logging utilities, EJB containers, Web Services technologies, etc.); those technologies are continuously updated, trashed, deprecated and forked, they're often patched when bugs or security issues are discovered, so it's really difficult to keep updated a framework that makes use of tons of them. Even the newest MDA framework runs the risk of becoming outdated in a truly short time. But this can also be interpreted as a strong point for MDA; think about the moment in which one of your business clients asks for a technology update for his application: if your MDA framework is constantly updated, you could be able to generate a new version of the old application simply using its old models and clicking on "generate". But, as far as I know, nobody has already achieved this level of quality (even if I presume we're not so far from it). </p> </section> <section><p>In conclusion, <strong>I think that a rough comparison between Model-Driven Architecture approach and hardcore coding is often the result of misconceptions about both of them</strong>. I don't think that MDA and hardcore coding should be so easily compared without mentioning their relative peculiarities, so, if asked about whether MDA could really be thought as a real substitute for old-style coding, my answer is <i>no, unless</i> we situate "old-stile coding" in an enterprise context (or a complex context in general). Yet, I expect a foreseeable future in which simpler MDA frameworks will help everyday users (even non-coders) to create their own applications with a growing level of accuracy. </p> <p>Comments and criticisms are more than accepted! </p></section> <section><h2f id="references17022014">References</h2f><ul><li><a href="http://en.wikipedia.org/wiki/Model-driven_architecture">Model-Driven Architecture</a></li><li><a href="http://en.wikipedia.org/wiki/Unified_Process">Unified Process</a></li></ul></section>
